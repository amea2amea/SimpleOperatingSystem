# 0から作る自作OS
このリポジトリは、0から自作OSを作るための内容をSTEPごとに分けてまとめたものです。

step0:
QEMU(エミュレータ)の起動

step1:
ブート処理
QEMU(RISC-V) -> OpenSBI -> ブート処理

step2:

# OSの基本的な仕組み
アプリケーションがOSからいろいろと情報を取得するのと同じようにOSはCPUやBIOSとやり取りを行うことで、作られています。アプリケーションを作るためにOSの仕様を理解するのと同じようにOSの仕組みを知るためにはCPUやBIOSの基本的な仕組みを把握しなければなりません。
そのため、基本的な知識についてまとめていきます。

# CPU
CPUは、複雑なものに見えますが、実際は、フェッチサイクルという命令実行サイクルを行っているだけで特殊なことは特にありません。高速化いわゆる性能を向上させるための様々な機能や仕組みがありますが、CPUの本質ではないので、理解していなくても問題はありません。
また、分かりにくくさせている要因としては、CPUごとにそれぞれの仕様があり、
オペコード(命令)の違いや同じC言語のコードでも吐き出されるアセンブリが異なる点でしょう。

[混乱する仕様]
表記の違いがある < AT&T記法(GAS) / インテル記法(NASM,MASM) >
CPUによりレジスタや命令が異なる
C言語のソースが同じでもCPUにより吐き出されるアセンブリコードは異なる
CISCとRISCがある
* これらの違いがあるのに書籍等には1つしかないように書かれているものが多い

[フェッチサイクル]
命令フェッチ(読み取り)：プログラムカウンタのアドレスにある命令を読み出す
命令デコード(解読)：アセンブリの命令を解読する
命令実行(実行)：アセンブリの命令を実行する
* プログラムカウンタは実行位置を示します。

[基本的な命令]
演算: add / sub (add,sub etc)
代入: move,
レジスタからメモリへ設定 (ストア) : store word (sw,sd etc)
メモリからレジスタへ読み込み（ロード) : load word (lw,ld etc)
ジャンプ : jump and link (jal,jai etc)
条件分岐 : branch not equal (bne,beq bnez etc) / blt (branch less than) / bge(branch greater equal)
* iは、即値を表す。add immediate (addi), load immediate (li)

[レジスタ]
CPU内部で保持する高速記憶領域であり、CPUの演算や制御処理に使用される領域。
レジスタには、一時的に使用する汎用レジスタと制御情報など記憶する制御レジスタがある。
CPUはメモリ上で演算処理やジャンプ処理などができないため、一旦レジスタに情報を確保する必要がある。
<代表的なレジスタ>
sp:スタックポインタ(スタックのトップ)
bp:ベースポインタ/フレームポインタ(関数ごとのスタック開始位置)
ra:関数から戻るアドレスを設定しておく

[CPUモード]
CPUには、最低でも2種類以上の動作モードを持ち、無制限のCPU動作を許モードをカーネルモード(スーパバイザーモード,特権モード)といい、他のモードはユーザーモード(スレーブモード)といわれる

[アセンブリ]
CPUにより吐き出されるアセンブリは異なりますが、吐き出されるアセンブリは次のような流れになっていることが一般的です。C言語やC++,pythonなどそれぞれの言語に流儀があるようにアセンブリにもアセンブリの流儀があるので、それを把握しておく必要があります。
1. スタックポインタの更新(push)
2. ベースポインタの設定
3. 一時レジスタなどをメモリに格納
4. 関数の処理
5. 一時レジスタを戻す
6. スタックポインタを戻す(pop)

# BIOS (Basic Input/Output System)
コンピュータの起動時に実行されるファームウェアで、コンピュータのハードウェアとソフトウェアの間の通信を仲介する役割を果たす。
具体的には、起動したPCにどんな機器が接続されているかを認識し、OSの読み込みを始めるところまでを担当する。
実は、BIOSというものは、現在は存在しておらず、2000年代中頃からIntelが主導して後継となるシステムUEFI（Unified Extensible Firmware Interface）が使用されている

[OpenSBI]
RISC-V Supervisor Binary Interface (SBI) 仕様のオープンソース

